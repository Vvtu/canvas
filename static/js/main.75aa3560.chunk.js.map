{"version":3,"sources":["utils/index.ts","canvas/index.js","App.tsx","reportWebVitals.ts","index.tsx"],"names":["COLOR","distance","a","b","Math","sqrt","x","y","fixedValue","Number","isInteger","toFixed","roundPointValue","point","p1","round","isChanged","abs","intersectionPoint","line1","line2","e","dx1","p2","dx2","dy1","dy2","a1","b1","c1","a2","b2","c2","i","bb2","calcMessage","point1","point2","message","dx","dy","k","Canvas","width","height","canvasRef","useRef","canvasRefBase","timeoutId","useState","isPainting","setIsPainting","setPoint1","setPoint2","point3","setPoint3","point4","setPoint4","twoLineIntersection","setTwoLineIntersection","toReal","useCallback","fromReal","useEffect","current","clearTimeout","updateLineWithNewCoordinates","event","canvas","coordinate","pageX","offsetLeft","pageY","offsetTop","indexMin","dist","forEach","d","index","setTimeout","mouseUp","mouseDown","addEventListener","removeEventListener","canvasBase","coordinatesGridRef","getContext","strokeStyle","lineWidth","beginPath","lines","max","from","to","moveTo","lineTo","closePath","stroke","from2","to2","context","drawLine","startPoint","endPoint","color","arc","PI","undefined","font","fillStyle","fillText","clearRect","intersec","inter","className","style","ref","App","screenSize","setScreenSize","updateSize","rect","getBoundingClientRect","useLayoutEffect","window","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.75aa3560.chunk.js","sourcesContent":["export const COLOR = {\n  line1: \"red\",\n  line2: \"blue\",\n  base: \"#ddd\",\n  ordinates: \"#000\",\n};\n\nexport type ICoordinate = {\n  x: number;\n  y: number;\n};\n\nexport const distance = (a: ICoordinate, b: ICoordinate) =>\n  Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);\n\nexport const fixedValue = (x: number) =>\n  Number.isInteger(x) ? x.toFixed(0) : x.toFixed(2);\n\nexport const roundPointValue = (point: ICoordinate) => {\n  const p1 = { ...point };\n  const a = Math.round(p1.x);\n  let isChanged = false;\n  if (Math.abs(a - p1.x) < 0.1) {\n    p1.x = a;\n    isChanged = true;\n  }\n  const b = Math.round(p1.y);\n  if (Math.abs(b - p1.y) < 0.2) {\n    p1.y = b;\n    isChanged = true;\n  }\n  if (isChanged) {\n    return p1;\n  }\n  return point;\n};\n\nexport type ILine = {\n  p1: ICoordinate;\n  p2: ICoordinate;\n};\n\nexport function intersectionPoint(line1: ILine, line2: ILine) {\n  let dx1 = line1.p2.x - line1.p1.x;\n  let dx2 = line2.p2.x - line2.p1.x;\n  let dy1 = line1.p2.y - line1.p1.y;\n  let dy2 = line2.p2.y - line2.p1.y;\n\n  let a1 = dy1;\n  let b1 = -dx1;\n  let c1 = line1.p1.y * dx1 - line1.p1.x * dy1;\n\n  let a2 = dy2;\n  let b2 = -dx2;\n  let c2 = line2.p1.y * dx2 - line2.p1.x * dy2;\n\n  let e;\n  for (let i = 0; i < 2; i += 1) {\n    if (a1 !== 0) {\n      let bb1 = (b1 * a2) / a1;\n      let cc1 = (c1 * a2) / a1;\n      let bb2 = b2 - bb1;\n      if (bb2 !== 0) {\n        let cc2 = c2 - cc1;\n        let y = -cc2 / bb2;\n        let x = (-c1 - b1 * y) / a1;\n        const result = i === 0 ? { x, y } : { x: y, y: x };\n        return result;\n      }\n    }\n    e = a1;\n    a1 = b1;\n    b1 = e;\n    e = a2;\n    a2 = b2;\n    b2 = e;\n  }\n  // --- ПРЯМЫЕ ПАРАЛЕЛЬНЫ ---\n  return {};\n}\n","import { useCallback, useEffect, useRef, useState } from \"react\";\n\nimport {\n  COLOR,\n  ICoordinate,\n  distance,\n  fixedValue,\n  roundPointValue,\n  intersectionPoint,\n} from \"../utils\";\ninterface CanvasProps {\n  width: number;\n  height: number;\n}\n\nconst SCALE = 60;\n\nconst calcMessage = (point1: ICoordinate, point2: ICoordinate) => {\n  const dx = point2.x - point1.x;\n  const dy = point2.y - point1.y;\n\n  let message;\n  if (dx === 0 && dy === 0) {\n    message = \"точки совпадают\";\n  } else {\n    if (dx === 0) {\n      message = \"k = ∞\";\n    } else {\n      const k = dy / dx;\n      const b = -point1.x * k + point1.y;\n      message = `y = ${fixedValue(k)} * x${\n        b === 0 ? \"\" : ` ${b > 0 ? \"+\" : \"\"} ${fixedValue(b)}`\n      }`;\n    }\n  }\n  return message;\n};\n\nconst Canvas = ({ width, height }: CanvasProps) => {\n  const canvasRef = useRef();\n  const canvasRefBase = useRef();\n  const timeoutId = useRef();\n\n  const [isPainting, setIsPainting] = useState(false);\n\n  const [point1, setPoint1] = useState({ x: -2, y: -2 });\n  const [point2, setPoint2] = useState({ x: 2, y: 2 });\n\n  const [point3, setPoint3] = useState({ x: 0, y: -2 });\n  const [point4, setPoint4] = useState({ x: 4, y: 2 });\n  const [twoLineIntersection, setTwoLineIntersection] = useState({});\n\n  const toReal = useCallback(\n    ({ x, y }: ICoordinate) => ({\n      x: x * SCALE + width / 2,\n      y: -y * SCALE + height / 2,\n    }),\n    [height, width]\n  );\n  const fromReal = useCallback(\n    ({ x, y }: ICoordinate) => ({\n      x: (x - width / 2) / SCALE,\n      y: -(y - height / 2) / SCALE,\n    }),\n    [height, width]\n  );\n\n  useEffect(() => {\n    return () => {\n      if (timeoutId.current) {\n        clearTimeout(timeoutId.current);\n      }\n    };\n  }, []);\n\n  const updateLineWithNewCoordinates = (\n    event: MouseEvent\n  ): ICoordinate | undefined => {\n    if (!canvasRef.current) {\n      return;\n    }\n    if (isPainting === false) {\n      return;\n    }\n    const canvas: HTMLCanvasElement = canvasRef.current;\n\n    const coordinate = fromReal({\n      x: event.pageX - canvas.offsetLeft,\n      y: event.pageY - canvas.offsetTop,\n    });\n    let indexMin = 0;\n    const dist = [\n      distance(coordinate, point1),\n      distance(coordinate, point2),\n      distance(coordinate, point3),\n      distance(coordinate, point4),\n    ];\n\n    dist.forEach((d, index) => {\n      if (d < dist[indexMin]) {\n        indexMin = index;\n      }\n    });\n\n    if (dist[indexMin] < 1.0) {\n      switch (indexMin) {\n        case 0:\n          setPoint1(coordinate);\n          break;\n        case 1:\n          setPoint2(coordinate);\n          break;\n        case 2:\n          setPoint3(coordinate);\n          break;\n        case 3:\n          setPoint4(coordinate);\n          break;\n        default:\n          break;\n      }\n    }\n\n    if (timeoutId.current) {\n      clearTimeout(timeoutId.current);\n    }\n\n    timeoutId.current = setTimeout(() => {\n      setPoint1(roundPointValue(point1));\n      setPoint2(roundPointValue(point2));\n      setPoint3(roundPointValue(point3));\n      setPoint4(roundPointValue(point4));\n    }, 300);\n  };\n\n  const mouseUp = () => setIsPainting(false);\n  const mouseDown = () => setIsPainting(true);\n\n  useEffect(() => {\n    if (!canvasRef.current) {\n      return;\n    }\n    const canvas: HTMLCanvasElement = canvasRef.current;\n    canvas.addEventListener(\"mousedown\", mouseDown);\n    canvas.addEventListener(\"mousemove\", updateLineWithNewCoordinates);\n    canvas.addEventListener(\"mouseup\", mouseUp);\n    canvas.addEventListener(\"touchstart\", mouseDown);\n    canvas.addEventListener(\"touchend\", mouseUp);\n    canvas.addEventListener(\"touchmove\", updateLineWithNewCoordinates);\n\n    return () => {\n      canvas.removeEventListener(\"mousedown\", mouseDown);\n      canvas.removeEventListener(\"mousemove\", updateLineWithNewCoordinates);\n      canvas.removeEventListener(\"mouseup\", mouseUp);\n      canvas.removeEventListener(\"touchstart\", mouseDown);\n      canvas.removeEventListener(\"touchend\", mouseUp);\n      canvas.removeEventListener(\"touchmove\", updateLineWithNewCoordinates);\n    };\n  });\n\n  useEffect(() => {\n    if (!canvasRefBase.current) {\n      return;\n    }\n    const canvasBase: HTMLCanvasElement = canvasRefBase.current;\n    const coordinatesGridRef = canvasBase.getContext(\"2d\");\n    if (coordinatesGridRef) {\n      coordinatesGridRef.strokeStyle = COLOR.base;\n      coordinatesGridRef.lineWidth = 1;\n\n      coordinatesGridRef.beginPath();\n\n      const lines = Math.round(\n        Math.max(canvasBase.height, canvasBase.width) / SCALE / 2\n      );\n      for (let x = -lines; x < lines; x += 1) {\n        const from = toReal({ x, y: 0 });\n        const to = toReal({ x, y: 0 });\n        coordinatesGridRef.moveTo(from.x, 0);\n        coordinatesGridRef.lineTo(to.x, canvasBase.height);\n      }\n      for (let y = -lines; y < lines; y += 1) {\n        const from = toReal({ x: 0, y });\n        const to = toReal({ x: 0, y });\n        coordinatesGridRef.moveTo(0, from.y);\n        coordinatesGridRef.lineTo(canvasBase.width, to.y);\n      }\n      coordinatesGridRef.closePath();\n      coordinatesGridRef.stroke();\n\n      coordinatesGridRef.strokeStyle = COLOR.ordinates;\n      coordinatesGridRef.lineWidth = 1;\n      coordinatesGridRef.beginPath();\n      // x\n      const from = toReal({ x: -lines, y: 0 });\n      const to = toReal({ x: lines, y: 0 });\n      coordinatesGridRef.moveTo(from.x, from.y);\n      coordinatesGridRef.lineTo(to.x + 10, to.y);\n      // arrow x\n      coordinatesGridRef.moveTo(canvasBase.width - 15, to.y - 3);\n      coordinatesGridRef.lineTo(canvasBase.width - 2, to.y);\n      coordinatesGridRef.moveTo(canvasBase.width - 15, to.y + 3);\n      coordinatesGridRef.lineTo(canvasBase.width - 2, to.y);\n      // y\n      const from2 = toReal({ x: 0, y: -lines });\n      const to2 = toReal({ x: 0, y: lines });\n      coordinatesGridRef.moveTo(from2.x, from2.y);\n      coordinatesGridRef.lineTo(to2.x, to2.y);\n      // arrow y\n      coordinatesGridRef.moveTo(to2.x - 3, 15);\n      coordinatesGridRef.lineTo(to2.x, 2);\n      coordinatesGridRef.moveTo(to2.x + 3, 15);\n      coordinatesGridRef.lineTo(to2.x, 2);\n      //\n      coordinatesGridRef.closePath();\n      coordinatesGridRef.stroke();\n    }\n  }, [toReal]);\n\n  useEffect(() => {\n    if (!canvasRef.current) {\n      return;\n    }\n    const canvas: HTMLCanvasElement = canvasRef.current;\n    const context = canvas.getContext(\"2d\");\n    if (context) {\n      context.clearRect(0, 0, canvas.width, canvas.height);\n\n      function drawLine(\n        startPoint: ICoordinate,\n        endPoint: ICoordinate,\n        color: string\n      ) {\n        context.strokeStyle = color;\n        context.lineWidth = 3;\n        context.beginPath();\n\n        const from = toReal(startPoint);\n        const to = toReal(endPoint);\n\n        context.moveTo(from.x, from.y);\n        context.arc(from.x, from.y, 3, 0, Math.PI * 2, true);\n        context.moveTo(to.x, to.y);\n        context.arc(to.x, to.y, 3, 0, Math.PI * 2, true);\n\n        let p1 = intersectionPoint(\n          { p1: from, p2: to },\n          { p1: { x: 0, y: 0 }, p2: { x: 0, y: canvas.height } }\n        );\n        let p2 = intersectionPoint(\n          { p1: from, p2: to },\n          {\n            p1: { x: canvas.width, y: 0 },\n            p2: { x: canvas.width, y: canvas.height },\n          }\n        );\n\n        if (p1.x === undefined || p2.x === undefined) {\n          // прямая расположена вертикально\n          p1 = { x: from.x, y: 0 };\n          p2 = { x: from.x, y: canvas.height };\n        }\n\n        context.moveTo(p1.x, p1.y);\n        context.lineTo(p2.x, p2.y);\n\n        context.closePath();\n        context.stroke();\n\n        context.font = \"30px serif\";\n\n        context.fillStyle = color;\n        context.fillText(\n          `(${fixedValue(startPoint.x)} ; ${fixedValue(startPoint.y)} )`,\n          from.x + 15,\n          from.y - 5\n        );\n        context.fillText(\n          `(${fixedValue(endPoint.x)} ; ${fixedValue(endPoint.y)} )`,\n          to.x + 15,\n          to.y - 5\n        );\n      }\n      drawLine(point1, point2, COLOR.line1);\n      drawLine(point3, point4, COLOR.line2);\n      const intersec = intersectionPoint(\n        { p1: point1, p2: point2 },\n        { p1: point3, p2: point4 }\n      );\n\n      setTwoLineIntersection(intersec);\n      if (intersec.x !== undefined) {\n        const inter = toReal(intersec);\n\n        context.strokeStyle = \"grey\";\n        context.lineWidth = 3;\n        context.beginPath();\n        context.moveTo(inter.x, inter.y);\n        context.arc(inter.x, inter.y, 3, 0, Math.PI * 2, true);\n        context.fillStyle = \"black\";\n        context.fillText(\n          `(${fixedValue(intersec.x)} ; ${fixedValue(intersec.y)} )`,\n          inter.x + 15,\n          inter.y - 5\n        );\n        context.closePath();\n        context.stroke();\n      }\n    }\n  }, [point1, point2, point3, point4, toReal]);\n\n  return (\n    <>\n      <div className=\"message\">\n        <div style={{ color: COLOR.line1 }}> {calcMessage(point1, point2)}</div>\n        <div style={{ color: COLOR.line2 }}> {calcMessage(point3, point4)}</div>\n        <div style={{ color: \"grey\" }}>\n          {twoLineIntersection.x === undefined\n            ? \"∅ ( прямые паралельны )\"\n            : `точка пересечения (${fixedValue(\n                twoLineIntersection.x\n              )} ; ${fixedValue(twoLineIntersection.y)} )`}\n        </div>\n      </div>\n      <div className=\"fullScreen\">\n        <canvas ref={canvasRefBase} height={height} width={width} />\n      </div>\n      <div className=\"fullScreen\">\n        <canvas ref={canvasRef} height={height} width={width} />\n      </div>\n    </>\n  );\n};\n\nexport default Canvas;\n","import Canvas from \"./canvas\";\nimport \"./App.css\";\n\nimport { useLayoutEffect, useRef, useState } from \"react\";\n\nfunction App() {\n  const ref = useRef<any>();\n  const timeoutId = useRef<any>();\n  const [screenSize, setScreenSize] = useState({ width: 600, height: 600 });\n\n  function updateSize() {\n    if (timeoutId.current) {\n      clearTimeout(timeoutId.current);\n    }\n    timeoutId.current = setTimeout(() => {\n      if (ref.current) {\n        const rect = ref.current.getBoundingClientRect();\n        setScreenSize({ width: rect.width, height: rect.height });\n      }\n    }, 200);\n  }\n\n  useLayoutEffect(() => {\n    updateSize();\n    window.addEventListener(\"resize\", updateSize);\n    return () => {\n      window.removeEventListener(\"resize\", updateSize);\n      if (timeoutId.current) {\n        clearTimeout(timeoutId.current);\n      }\n    };\n  }, []);\n\n  return (\n    <div className=\"App fullScreen\" ref={ref}>\n      <Canvas width={screenSize.width} height={screenSize.height} />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}